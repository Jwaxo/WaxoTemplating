module.exports = function(tags) {

	waxoCompile = function(string) {

		//After the previous parsing is complete, we parse remaining variable
		//replacements, starting out by first listing what variables we'll need
		//to be watching out for.
		
		//And now create the function that will be run after the initial string set
		var toBeRendered = function(replacements) {
		
			var parser = new Parser(replacements);
			parser.parse(tags);
			
			var finalHTML = null;
			
			//The way this is set up implies that the parser can have its code
			//functions looked up before the replacement tags are set, which
			//should be impossible, so we have waited until we receive our
			//replacements to try to parse.

			var funcChop = /{%\s*([\w\d\s\-\.]*)\s*%}/gi; //Find functions
			
			while (funcChopBit = funcChop.exec(string)) {
				console.log("Reading function '" + funcChopBit[1] + "'.");
				possibleFunction = funcChopBit[1].split(/\s+/);
				var parsedFunction = parser.findFunc(possibleFunction[0]);
				if (parsedFunction != undefined) {
					runParsed = parsedFunction(parser,funcChopBit[1]);
					finalHTML += runParsed([{okay: true}, {okay: false}]);
				}
			}
			
			var tagChop = /(\{\{\s*)(\w+?)(\s*\}\})/g; //Find tags
			var tagChopBits = string.match(tagChop); 
			console.log('Adding template variables ' + tagChopBits);
			
			for (var i=0;i<tagChopBits.length;i++) {
				console.log('Replacing template bits.')
				//Here we loop through the initial variables and see if that
				//variable was submitted, after first chopping the brackets off
				var shorterBit = tagChopBits[i].replace(/\{\{\s*(.*?)\s*\}\}/, "$1");
				console.log("Replacing instance of '" + tagChopBits[i] + "'.");
				if(replacements.hasOwnProperty(shorterBit)) {
					finalHTML = string.replace(tagChopBits[i],replacements[shorterBit]);
				}
			}
			console.log('Template variables replaced.')
			return finalHTML; //And return the final HTML
		}
		
		return toBeRendered;
	}
	
	return waxoCompile;
	
};

function Parser(tags) {

	this.functions = {};
	
	this.tags = tags;
	
	this.parse = function(tags) {
		for (var t in tags) {
			console.log("Saving new functions '" + t + "'.");
			this.functions[t] = tags[t];
		}
	}
	
	this.findFunc = function(bit) {
		console.log("Looking up parser function '" + bit + "'.");
		if (this.functions.hasOwnProperty(bit)) {
			return this.functions[bit];
		}
	}
	
	this.lookup = function(bit) {
		console.log("Looking up parser tag '" + bit + "'.");
		if (this.tags.hasOwnProperty(bit)) {
			parsedTags = this.tags;
			return function() {
				return parsedTags[bit];
			}
		}
	}
}