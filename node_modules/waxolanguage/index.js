module.exports = function(tags) {


	waxoCompile = function(string) {
		
		//After the previous parsing is complete, we parse remaining variable
		//replacements, starting out by first listing what variables we'll need
		//to be watching out for.
		
		//And now create the function that will be run after the initial string set
		var toBeRendered = function(replacements) {
		
			var parser = new Parser(replacements);
			parser.parse(tags);
			
			var finalHTML = null;
			
			//The way this is set up implies that the parser can have its code
			//functions looked up before the replacement tags are set, which
			//should be impossible, so we have waited until we receive our
			//replacements to try to parse.

			string = parser.search(string, null);
			
			var tagChop = /(\{\{\s*)(\w+?)(\s*\}\})/g; //Find tags
			var tagChopBits = string.match(tagChop); 
			console.log('Adding template variables ' + tagChopBits);
			
			if (tagChopBits != null) {
				for (var i=0;i<tagChopBits.length;i++) {
					console.log('Replacing template bits.')
					//Here we loop through the initial variables and see if that
					//variable was submitted, after first chopping the brackets off
					var shorterBit = tagChopBits[i].replace(/\{\{\s*(.*?)\s*\}\}/, "$1");
					console.log("Replacing instance of '" + tagChopBits[i] + "'.");
					if(replacements.hasOwnProperty(shorterBit)) {
						string = string.replace(tagChopBits[i],replacements[shorterBit]);
					}
				}
			}
			console.log('Template variables replaced.')
			return string; //And return the final HTML
		}
		
		return toBeRendered;
	}
	
	return waxoCompile;
	
};

function Parser(tags) {

	this.functions = {};
	
	this.tags = tags;
	
	this.parse = function(tags) {
		for (var t in tags) {
			console.log("Saving new functions '" + t + "'.");
			this.functions[t] = tags[t];
		}
	}
	
	this.search = function(string, searched) {
		var funcChop = /{%\s*([\w\d\s\-\.]*)\s*%}/gi; //Find functions
		var funcChopBit = null;
		
		while (funcChopBit = funcChop.exec(string)) {
			console.log("Reading function '" + funcChopBit[1] + "' at index " + funcChopBit.index + " with length of " + funcChopBit[0].length + ".");
			var possibleFunction = funcChopBit[1].split(/\s+/);
			var parsedFunction = this.findFunc(possibleFunction[0]);
			if (parsedFunction != undefined) {
				if (possibleFunction[0] == 'end' + searched) {
					console.log("Found end of parsed function '" + searched + "', returning.");
					return parsedFunction(string, funcChopBit);
				} else {
					var runParsed = parsedFunction(this,funcChopBit[1]);
					var hasEnd = this.findFunc('end' + possibleFunction[0]);
					if (hasEnd != undefined) {
						var endParsed = this.search(string.substring(
							funcChopBit.index + funcChopBit[0].length
						), possibleFunction[0]);
					}
					
					console.log("And we have parsed: '" + endParsed.tpl + "' from function '" + possibleFunction[0] + "'.");
					var parsedString = runParsed(string, endParsed.tpl);
					console.log("Replacing '" + parsedString + "' into '" + string + "' starting at " + funcChopBit.index + " and ending at " + endParsed.endpoint + ".");
					return string = this.replaceInto(funcChopBit.index, endParsed.endpoint + funcChopBit[0].length, parsedString, string);
				}
			}
		}
	}
	
	this.findFunc = function(bit) {
		console.log("Looking up parser function '" + bit + "'.");
		if (this.functions.hasOwnProperty(bit)) {
			return this.functions[bit];
		}
	}
	
	this.lookup = function(bit) {
		console.log("Looking up variable tag '" + bit + "'.");
		if (this.tags.hasOwnProperty(bit)) {
			parsedTags = this.tags;
			return function() {
				return parsedTags[bit];
			}
		}
	}
	
	this.replaceInto = function(startDex, endDex, from, to) {
		return to.substring(0, startDex) + from + to.substring(endDex);
	}
}