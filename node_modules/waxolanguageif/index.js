//The "if" functionality for waxoLanguage
module.exports = function(parser, contents) { 
	console.log("Attempting to run 'if' function.");

	parser.parse({
	  "endif" : endif //The ending function MUST be "end + initial function"
	});

	return function(string, content) {

		var elseTypes = parser.searchSpecifics(content, ["elseif","else"]);
		var ifTests = Array();

		//if has a couple of special cases. Since none of them really have specific
		//"end" tags, we treat them differently: we build an array of them,
		//splitting up the if/elseif/else chains into separate statements, then
		//step through them to find our winner.
		
		var bits = contents.split(/\s+/)  // ["if", "function"+]
		var ifFunction = "";
		
		var waxoDotpath = require('waxodotpath');
		
		for (i = 1;i<bits.length;i++) {
			ifFunction += " " + bits[i]; //This turns everything after "if " into a
			//legible function
		}
		
		if(elseTypes.length > 0) {
			for(var i=0;i<elseTypes.length;i++) {
				var currentTest = {};
				//console.log("Elsetype found: " + elseTypes[i]);
				var elseBits = elseTypes[i][1].split(/\s+/)  // ["elseif", "function"+]
				var elseifFunction;
				if (elseBits[0] == 'elseif') {
					for (j = 1;j<elseBits.length;j++) {
						elseifFunction += " " + elseBits[j]; //This turns everything after "if " into a
						//legible function
					}
					currentTest = {
						"type" : "elseif"
					  , "ifFunction" : elseifFunction
					  , "startIndex" : elseTypes[i].index
					  , "endIndex" : elseTypes[i].index + elseTypes[i][0].length
					}
				} else if (elseBits[0] = 'else') { //I realize the irony of finding
				//the 'else' case with 'else if'
					currentTest = {
						"type" : "else"
					  , "startIndex" : elseTypes[i].index
					  , "endIndex" : elseTypes[i].index + elseTypes[i][0].length
					}
				}
				if (i == 0) {
					firstTest = {
						"type" : "if"
					  , "ifFunction" : ifFunction
					  , "startIndex" : 0
					  , "endIndex" : elseTypes[i].index
					}
					ifTests.push(firstTest);
				}
				ifTests.push(currentTest);
			}
		} else {
			firstTest = {
				"type" : "if"
			  , "ifFunction" : ifFunction
			  , "startIndex" : 0
			  , "endIndex" : content.length
			}
			ifTests.push(firstTest);
		}
		
		//Since our templater can't deal with actual evaluators, we replace them
		//with letter-based versions
		var evaluatorChop = /(\s(\w+)\s)/g;
		var dotpathChop = /\s(\w+\.\w+)*\s/gi;
		var modifiedString = '';
		
		for (var i = 0;i<ifTests.length;i++) {
			var evaluatorChopBit;
			var evaluator;
			if (ifTests[i].type != 'else') {
				ifFunction = ifTests[i].ifFunction;
				while (evaluatorChopBit = evaluatorChop.exec(ifFunction)) {
					switch(evaluatorChopBit[1].trim()) {
						case 'eq':
							evaluator = ' == ';
							break;
						case 'neq':
							evaluator = ' != ';
							break;
						case 'gt':
							evaluator = ' > ';
							break;
						case 'lt':
							evaluator = ' < ';
							break;
						case 'gte':
							evaluator = ' >= ';
							break;
						case 'lte':
							evaluator = ' <= ';
							break;
					}
					if (evaluator != undefined) {
						ifFunction = parser.replaceInto(evaluatorChopBit.index, evaluatorChopBit.index + evaluatorChopBit[1].length, evaluator, ifFunction);
					}
				}
				
				//Then use my dotpath function to replace dotpath variables
				//with the value of their object properties
			
				//console.log("Searching for dotpaths in '" + ifFunction + "'.");
				var dotpathChopBit;
				while (dotpathChopBit = dotpathChop.exec(ifFunction)) {
					//console.log("Dotpath found: '" + dotpathChopBit[1] + "'.");
					var replacePath = waxoDotpath(dotpathChopBit[1].trim());
					var replaceVar = replacePath(parser.tags);
					ifFunction = parser.replaceInto(dotpathChopBit.index, dotpathChopBit.index + dotpathChopBit[1].length+1, replaceVar, ifFunction);
					//console.log("New ifFunction: '" + ifFunction + "'.");
				}
				console.log("Dotpaths replaced to form function '" + ifFunction + "'.");
				
				if (eval(ifFunction) == true){ //Since the statements we are
				//testing should be in order of if->else ifs->else, the first
				//one we hit as "true" will be the one we want.
					console.log("Function evaluated as 'true'.");
					modifiedString = content.substring(ifTests[i].startIndex,ifTests[i].endIndex);
					break;
				}
			} else {
				console.log("No true ifs found, going with else.");
				modifiedString = content.substring(ifTests[i].endIndex);
			}
		}
		
		return modifiedString;
	};
};

function endif(tpl, context) {
	//All we really need to define is what bit of the template we want, and the
	//stats of the endif tag.
	return {
		tpl: tpl.substring(0, context.index)
	  , endpoint: context.index + context[0].length
	};
}